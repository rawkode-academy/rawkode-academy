---
export const prerender = true;

import { getCollection } from "astro:content";
import Page from "@/wrappers/page.astro";
import { Container } from "@/components/ui";
import { resolveTechnologyIconUrl } from "@/utils/resolve-technology-icon";
import NewsletterCTA from "@/components/newsletter/NewsletterCTA.astro";

// Helper to normalize technology references from videos
function normalizeTechnologyRef(value: unknown): string | undefined {
	if (typeof value === "string") {
		return value.replace(/\/index$/, "");
	}
	if (typeof value === "object" && value !== null) {
		const ref = (value as any).id ?? (value as any).slug;
		if (typeof ref === "string") return ref.replace(/\/index$/, "");
	}
	return undefined;
}

// Compute video counts per technology
const allVideos = await getCollection("videos");
const videoCountsByTech = new Map<string, number>();
for (const video of allVideos) {
	const techs = video.data.technologies;
	if (Array.isArray(techs)) {
		for (const tech of techs) {
			const techId = normalizeTechnologyRef(tech);
			if (techId) {
				videoCountsByTech.set(techId, (videoCountsByTech.get(techId) || 0) + 1);
			}
		}
	}
}

// Types
type Grouping = "plumbing" | "platform" | "observability" | "security";
type PipelineStage =
	| "skip"
	| "watch"
	| "explore"
	| "learn"
	| "adopt"
	| "advocate";
type Confidence = "gut" | "some-experience" | "deep-experience";
type Trajectory = "rising" | "stable" | "falling";

const groupings: Grouping[] = [
	"plumbing",
	"platform",
	"observability",
	"security",
];
const pipelineStages: PipelineStage[] = [
	"skip",
	"watch",
	"explore",
	"learn",
	"adopt",
	"advocate",
];

const groupingLabels: Record<Grouping, string> = {
	plumbing: "Plumbing",
	platform: "Platform",
	observability: "Observability",
	security: "Security",
};

const groupingDescriptions: Record<Grouping, string> = {
	plumbing: "The invisible infrastructure",
	platform: "Building blocks for developers",
	observability: "Understanding what's happening",
	security: "Keeping things safe",
};

const groupingIcons: Record<Grouping, string> = {
	plumbing: "üîß",
	platform: "üèóÔ∏è",
	observability: "üìä",
	security: "üîí",
};

const stageLabels: Record<PipelineStage, string> = {
	skip: "Skip",
	watch: "Watch",
	explore: "Explore",
	learn: "Learn",
	adopt: "Adopt",
	advocate: "Advocate",
};

const stageDescriptions: Record<PipelineStage, string> = {
	skip: "Not for me",
	watch: "On my radar",
	explore: "Worth a look",
	learn: "Investing time",
	adopt: "Production ready",
	advocate: "Championing",
};

const trajectoryEmoji: Record<Trajectory, string> = {
	rising: "‚Üó",
	stable: "‚Üí",
	falling: "‚Üò",
};

// Get all technologies with matrix data
const allTechnologies = await getCollection("technologies");
const matrixTechnologies = allTechnologies
	.filter((tech) => tech.data.matrix?.status && tech.data.matrix?.grouping)
	.map((tech) => ({
		id: tech.id,
		name: tech.data.name,
		grouping: tech.data.matrix!.grouping as Grouping,
		status: tech.data.matrix!.status as PipelineStage,
		icon: resolveTechnologyIconUrl(tech.id, tech.data.logos),
		confidence: tech.data.matrix!.confidence as Confidence | undefined,
		trajectory: tech.data.matrix!.trajectory as Trajectory | undefined,
		// Card back fields
		why: tech.data.matrix!.why,
		firstUsed: tech.data.matrix!.firstUsed,
		lastUsed: tech.data.matrix!.lastUsed,
		makesMeFeel: tech.data.matrix!.makesMeFeel,
		spicyTake: tech.data.matrix!.spicyTake,
		videoCount: videoCountsByTech.get(tech.id) || 0,
		articleCount: 0, // TODO: Wire up when articles have technology links
	}));

// Build pipeline lanes (by grouping)
const pipelineLanes = groupings.map((grouping) => ({
	grouping,
	label: groupingLabels[grouping],
	description: groupingDescriptions[grouping],
	icon: groupingIcons[grouping],
	stages: Object.fromEntries(
		pipelineStages.map((stage) => [
			stage,
			matrixTechnologies.filter(
				(t) => t.grouping === grouping && t.status === stage,
			),
		]),
	) as Record<PipelineStage, typeof matrixTechnologies>,
}));

// Check for legacy status values and map them (only truly legacy values)
const legacyMapping: Record<string, PipelineStage> = {
	hold: "skip",
	assess: "watch",
	trial: "explore",
};

// Remap legacy values in pipeline lanes
pipelineLanes.forEach((lane) => {
	Object.entries(legacyMapping).forEach(([legacy, modern]) => {
		const legacyTech = matrixTechnologies.filter(
			(t) => t.grouping === lane.grouping && t.status === legacy,
		);
		if (legacyTech.length > 0) {
			lane.stages[modern] = [...lane.stages[modern], ...legacyTech];
		}
	});
});

// Calculate stats per stage
const stageStats = Object.fromEntries(
	pipelineStages.map((stage) => [
		stage,
		matrixTechnologies.filter((t) => t.status === stage).length,
	]),
) as Record<PipelineStage, number>;

// Graveyard: technologies with graveyard status OR deprecated/abandoned status
type TechnologyStatus =
	| "alpha"
	| "beta"
	| "stable"
	| "preview"
	| "superseded"
	| "deprecated"
	| "abandoned";
const graveyardTechnologies = allTechnologies
	.filter(
		(tech) =>
			tech.data.matrix?.status === "graveyard" ||
			tech.data.status === "deprecated" ||
			tech.data.status === "abandoned",
	)
	.map((tech) => ({
		id: tech.id,
		name: tech.data.name,
		status: tech.data.status as TechnologyStatus,
		grouping: tech.data.matrix?.grouping as Grouping | undefined,
		matrixStatus: tech.data.matrix?.status,
		icon: resolveTechnologyIconUrl(tech.id, tech.data.logos),
		confidence: tech.data.matrix?.confidence as Confidence | undefined,
		trajectory: tech.data.matrix?.trajectory as Trajectory | undefined,
		why: tech.data.matrix?.why,
		firstUsed: tech.data.matrix?.firstUsed,
		lastUsed: tech.data.matrix?.lastUsed,
		makesMeFeel: tech.data.matrix?.makesMeFeel,
		spicyTake: tech.data.matrix?.spicyTake,
		videoCount: videoCountsByTech.get(tech.id) || 0,
		articleCount: 0,
	}));

const techStatusLabels: Record<string, string> = {
	deprecated: "Deprecated",
	abandoned: "Abandoned",
};
---

<Page
	title="Technology Matrix"
	description="Rawkode's opinionated guide to cloud native and platform engineering technologies."
>
	<!-- Custom Hero -->
	<section class="matrix-hero">
		<div class="hero-background">
			<div class="hero-gradient"></div>
			<div class="hero-grid"></div>
		</div>
		<Container size="xl" padding="lg">
			<div class="hero-content">
				<div class="hero-badge glass-chip">
					<span class="badge-dot"></span>
					<span>{matrixTechnologies.length} Technologies Mapped</span>
				</div>
				<h1 class="hero-title">
					Technology <span class="title-accent">Matrix</span>
				</h1>
				<p class="hero-subtitle text-secondary-content">
					My opinionated journey through cloud native technologies.
					<br class="hidden md:block" />
					From first glance to full advocacy.
				</p>

				<!-- Mini pipeline preview / Filter buttons -->
				<div class="hero-pipeline-preview" role="group" aria-label="Filter by stage">
					{pipelineStages.map((stage) => (
						<button
							type="button"
							class={`preview-stage preview-${stage}`}
							data-filter={stage}
							aria-pressed="false"
						>
							<span class="preview-count">{stageStats[stage]}</span>
							<span class="preview-label">{stageLabels[stage]}</span>
						</button>
					))}
					<button
						type="button"
						class="preview-stage preview-graveyard"
						data-filter="graveyard"
						aria-pressed="false"
					>
						<span class="preview-count">{graveyardTechnologies.length}</span>
						<span class="preview-label">Graveyard</span>
					</button>
				</div>
			</div>
		</Container>
	</section>

	<Container size="xl" padding="lg">
		<!-- Matrix Updates CTA -->
		<NewsletterCTA
			server:defer
			class="mb-8"
			audience="matrix"
			badge="Matrix updates in your inbox"
			headline="Track my technology journey"
			subtitle="Get notified when I move technologies through the matrix‚Äînew discoveries, changed opinions, and spicy takes."
		/>

		<div class="matrix-content">

			<!-- Pipeline Header -->
			<div class="pipeline-header" role="img" aria-label="Pipeline stages from Skip to Advocate">
				<div class="header-flow-line"></div>
				{pipelineStages.map((stage, idx) => (
					<div class={`header-stage header-${stage}`} style={`--stage-index: ${idx}`}>
						<div class="stage-arrow">
							<div class="arrow-body">
								<span class="stage-label">{stageLabels[stage]}</span>
								<span class="stage-sublabel">{stageDescriptions[stage]}</span>
							</div>
							<div class="arrow-point"></div>
						</div>
					</div>
				))}
			</div>

			<!-- Pipeline Lanes -->
			<div class="pipeline-lanes">
				{pipelineLanes.map((lane, laneIdx) => (
					<div class="lane-wrapper" style={`--lane-index: ${laneIdx}`} data-lane={lane.grouping}>
						<div class="lane-tabs">
							<div class="lane-tab">
								<span class="lane-icon">{lane.icon}</span>
								<span class="lane-title">{lane.label}</span>
								<span class="lane-desc text-muted">‚Äî {lane.description}</span>
							</div>
							<div class="lane-hover-tab" aria-hidden="true">
								<span class="hover-tab-name"></span>
								<span class="hover-tab-arrow">‚Üí</span>
							</div>
						</div>
						<div class="lane glass-card">
							<div class="lane-grid">
								{pipelineStages.map((stage) => (
									<div class={`lane-cell cell-${stage}`}>
										{lane.stages[stage].length > 0 ? (
											<div class="cell-content">
												{lane.stages[stage].map((tech) => (
													<a
														href={`/technology/${tech.id}`}
														class={`tech-icon chip-${stage}`}
														data-name={tech.name}
														data-id={tech.id}
														data-status={tech.status}
														data-grouping={tech.grouping}
														data-why={tech.why || ""}
														data-first-used={tech.firstUsed || ""}
														data-last-used={tech.lastUsed || ""}
														data-makes-me-feel={tech.makesMeFeel || ""}
														data-spicy-take={tech.spicyTake || ""}
														data-video-count={tech.videoCount}
														data-article-count={tech.articleCount}
														data-confidence={tech.confidence || ""}
														data-trajectory={tech.trajectory || ""}
														data-icon={tech.icon || ""}
													>
														{tech.icon ? (
															<img src={tech.icon} alt={tech.name} class="icon-img" loading="lazy" />
														) : (
															<span class="icon-initial">{tech.name[0]}</span>
														)}
														{tech.trajectory && (
															<span class={`icon-trajectory trajectory-${tech.trajectory}`}>
																{trajectoryEmoji[tech.trajectory]}
															</span>
														)}
													</a>
												))}
											</div>
										) : (
											<div class="cell-empty"></div>
										)}
									</div>
								))}
							</div>
						</div>
						<!-- Card Back (slides down on hover) - Playing Card Style -->
						<div class="card-back" aria-hidden="true">
							<div class="playing-card">
								<!-- Card Inner Frame -->
								<div class="card-frame">
									<!-- Top Section: Icon + Name -->
									<div class="card-top">
										<div class="card-identity">
											<img class="card-back-icon" src="" alt="" />
											<div class="card-titles">
												<h3 class="card-back-name"></h3>
												<span class="card-back-position"></span>
											</div>
										</div>
										<span class="card-emoji"></span>
									</div>

									<!-- Center: The Why -->
									<div class="card-center">
										<p class="card-back-why"></p>
									</div>

									<!-- Stats Strip -->
									<div class="card-stats-strip">
										<div class="card-stat">
											<span class="stat-value stat-videos">0</span>
											<span class="stat-label">Videos</span>
										</div>
										<div class="card-stat">
											<span class="stat-value stat-articles">0</span>
											<span class="stat-label">Articles</span>
										</div>
										<div class="card-stat">
											<span class="stat-value stat-first-used">‚Äî</span>
											<span class="stat-label">First Used</span>
										</div>
										<div class="card-stat">
											<span class="stat-value stat-last-used">‚Äî</span>
											<span class="stat-label">Last Used</span>
										</div>
										<div class="card-stat">
											<span class="stat-value stat-confidence">‚Äî</span>
											<span class="stat-label">Confidence</span>
										</div>
									</div>

									<!-- Spicy Take -->
									<div class="card-back-spicy">
										<span class="spicy-icon">üå∂Ô∏è</span>
										<span class="spicy-take"></span>
									</div>

									<!-- Bottom CTA -->
									<a class="card-cta-link" href="">
										<span>View Details</span>
										<svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
											<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6" />
										</svg>
									</a>
								</div>
							</div>
						</div>
					</div>
				))}
			</div>

			<!-- Graveyard Section -->
			{graveyardTechnologies.length > 0 && (
				<div class="graveyard-section">
					<div class="graveyard-header">
						<div class="graveyard-title-group">
							<span class="graveyard-icon">ü™¶</span>
							<h2 class="graveyard-title">Graveyard</h2>
						</div>
						<p class="graveyard-subtitle text-muted">Deprecated, abandoned, or burned me</p>
					</div>
					<div class="graveyard-grid glass-card">
						{graveyardTechnologies.map((tech) => (
							<a
								href={`/technology/${tech.id}`}
								class="graveyard-item"
								data-name={tech.name}
								data-id={tech.id}
								data-status={tech.matrixStatus || ""}
								data-grouping={tech.grouping || ""}
								data-why={tech.why || ""}
								data-first-used={tech.firstUsed || ""}
								data-last-used={tech.lastUsed || ""}
								data-makes-me-feel={tech.makesMeFeel || ""}
								data-spicy-take={tech.spicyTake || ""}
								data-video-count={tech.videoCount}
								data-article-count={tech.articleCount}
								data-confidence={tech.confidence || ""}
								data-trajectory={tech.trajectory || ""}
								data-icon={tech.icon || ""}
							>
								<div class="graveyard-icon-wrapper">
									{tech.icon ? (
										<img src={tech.icon} alt={tech.name} class="graveyard-img" loading="lazy" />
									) : (
										<span class="graveyard-initial">{tech.name[0]}</span>
									)}
								</div>
								<div class="graveyard-info">
									<span class="graveyard-name">{tech.name}</span>
									<span class={`graveyard-status status-${tech.status}`}>
										{techStatusLabels[tech.status] || tech.status}
									</span>
								</div>
							</a>
						))}
					</div>
				</div>
			)}

		</div>
	</Container>
</Page>

<style>
	/* ===== HERO ===== */
	.matrix-hero {
		position: relative;
		padding: 4rem 0 3rem;
		overflow: hidden;
	}

	.hero-background {
		position: absolute;
		inset: 0;
		z-index: 0;
	}

	.hero-gradient {
		position: absolute;
		inset: 0;
		background:
			radial-gradient(ellipse 80% 50% at 50% -20%, rgb(var(--brand-primary) / 0.15), transparent),
			radial-gradient(ellipse 60% 40% at 80% 50%, rgb(var(--brand-secondary) / 0.1), transparent),
			radial-gradient(ellipse 50% 30% at 20% 80%, rgb(var(--brand-primary) / 0.08), transparent);
	}

	.hero-grid {
		position: absolute;
		inset: 0;
		background-image:
			linear-gradient(var(--surface-border) 1px, transparent 1px),
			linear-gradient(90deg, var(--surface-border) 1px, transparent 1px);
		background-size: 60px 60px;
		mask-image: radial-gradient(ellipse at center, black, transparent 70%);
	}

	.hero-content {
		position: relative;
		z-index: 1;
		text-align: center;
	}

	.hero-badge {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
		margin-bottom: 1.5rem;
	}

	.badge-dot {
		width: 6px;
		height: 6px;
		background: rgb(var(--brand-primary));
		border-radius: 50%;
		animation: pulse 2s ease-in-out infinite;
	}

	@keyframes pulse {
		0%, 100% { opacity: 1; transform: scale(1); }
		50% { opacity: 0.5; transform: scale(1.2); }
	}

	.hero-title {
		font-size: clamp(2.5rem, 6vw, 4rem);
		font-weight: 800;
		letter-spacing: -0.03em;
		line-height: 1.1;
		margin: 0 0 1rem;
	}

	.title-accent {
		background: linear-gradient(135deg, rgb(var(--brand-primary)), rgb(var(--brand-secondary)));
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	.hero-subtitle {
		font-size: 1.125rem;
		margin: 0 0 2.5rem;
		line-height: 1.6;
	}

	/* Hero Pipeline Preview */
	.hero-pipeline-preview {
		display: flex;
		justify-content: center;
		gap: 0.25rem;
		flex-wrap: wrap;
		max-width: 600px;
		margin: 0 auto;
	}

	.preview-stage {
		display: flex;
		flex-direction: column;
		align-items: center;
		padding: 0.75rem 1rem;
		border-radius: 8px;
		min-width: 70px;
		transition: transform 0.2s ease, box-shadow 0.2s ease;
		border: 1px solid var(--surface-border);
	}

	.preview-stage:hover {
		transform: translateY(-2px);
	}

	.preview-count {
		font-size: 1.25rem;
		font-weight: 700;
	}

	.preview-label {
		font-size: 0.65rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.05em;
		opacity: 0.8;
	}

	/* Pipeline stage colors - these are semantic to the matrix concept */
	.preview-skip { background: rgba(239, 68, 68, 0.15); color: rgb(239, 68, 68); }
	.preview-watch { background: rgba(249, 115, 22, 0.15); color: rgb(249, 115, 22); }
	.preview-explore { background: rgba(234, 179, 8, 0.15); color: rgb(180, 130, 0); }
	.preview-learn { background: rgba(59, 130, 246, 0.15); color: rgb(59, 130, 246); }
	.preview-adopt { background: rgba(34, 197, 94, 0.15); color: rgb(34, 197, 94); }
	.preview-advocate { background: rgb(var(--brand-primary) / 0.15); color: rgb(var(--brand-primary)); }

	html.dark .preview-skip { background: rgba(239, 68, 68, 0.2); color: rgb(252, 165, 165); }
	html.dark .preview-watch { background: rgba(249, 115, 22, 0.2); color: rgb(253, 186, 116); }
	html.dark .preview-explore { background: rgba(234, 179, 8, 0.2); color: rgb(253, 224, 71); }
	html.dark .preview-learn { background: rgba(59, 130, 246, 0.2); color: rgb(147, 197, 253); }
	html.dark .preview-adopt { background: rgba(34, 197, 94, 0.2); color: rgb(134, 239, 172); }
	html.dark .preview-advocate { background: rgb(var(--brand-primary) / 0.25); color: rgb(var(--brand-secondary)); }

	/* Graveyard preview button */
	.preview-graveyard { background: rgba(107, 114, 128, 0.15); color: rgb(107, 114, 128); }
	html.dark .preview-graveyard { background: rgba(107, 114, 128, 0.25); color: rgb(156, 163, 175); }

	/* Filter button interactivity */
	.preview-stage {
		cursor: pointer;
		font-family: inherit;
	}

	.preview-stage[aria-pressed="true"] {
		transform: translateY(-2px);
		box-shadow: 0 0 0 2px currentColor;
	}

	.preview-stage:focus-visible {
		outline: 2px solid currentColor;
		outline-offset: 2px;
	}

	/* ===== MATRIX CONTENT ===== */
	.matrix-content {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	/* Filter states */
	.matrix-content[data-filter="graveyard"] .pipeline-header,
	.matrix-content[data-filter="graveyard"] .pipeline-lanes {
		display: none;
	}

	.matrix-content:not([data-filter="graveyard"])[data-filter] .graveyard-section {
		display: none;
	}

	/* Highlight filtered stage cells */
	.matrix-content[data-filter] .lane-cell {
		opacity: 0.3;
		transition: opacity 0.2s ease;
	}

	.matrix-content[data-filter="skip"] .lane-cell.cell-skip,
	.matrix-content[data-filter="watch"] .lane-cell.cell-watch,
	.matrix-content[data-filter="explore"] .lane-cell.cell-explore,
	.matrix-content[data-filter="learn"] .lane-cell.cell-learn,
	.matrix-content[data-filter="adopt"] .lane-cell.cell-adopt,
	.matrix-content[data-filter="advocate"] .lane-cell.cell-advocate {
		opacity: 1;
	}

	/* ===== PIPELINE HEADER ===== */
	.pipeline-header {
		display: flex;
		position: relative;
		gap: 4px;
		padding: 0 0 0.5rem;
	}

	.header-flow-line {
		position: absolute;
		bottom: 0;
		left: 0;
		right: 0;
		height: 2px;
		background: linear-gradient(90deg,
			rgb(239, 68, 68),
			rgb(249, 115, 22),
			rgb(234, 179, 8),
			rgb(59, 130, 246),
			rgb(34, 197, 94),
			rgb(var(--brand-primary))
		);
		border-radius: 2px;
		opacity: 0.5;
	}

	.header-stage {
		flex: 1;
		min-width: 0;
	}

	.stage-arrow {
		display: flex;
		align-items: stretch;
		height: 100%;
	}

	.arrow-body {
		flex: 1;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		padding: 1rem 0.5rem 1rem 1rem;
		border-radius: 12px 0 0 12px;
		position: relative;
		transition: all 0.2s ease;
	}

	.arrow-point {
		width: 20px;
		position: relative;
		flex-shrink: 0;
	}

	.arrow-point::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		width: 0;
		height: 0;
		border-top: 32px solid transparent;
		border-bottom: 32px solid transparent;
		border-left: 20px solid;
		border-left-color: inherit;
	}

	.header-stage:last-child .arrow-body {
		border-radius: 12px;
	}

	.header-stage:last-child .arrow-point {
		display: none;
	}

	/* Stage colors - semantic to matrix */
	.header-skip .arrow-body { background: rgb(239, 68, 68); }
	.header-skip .arrow-point::before { border-left-color: rgb(239, 68, 68); }

	.header-watch .arrow-body { background: rgb(249, 115, 22); }
	.header-watch .arrow-point::before { border-left-color: rgb(249, 115, 22); }

	.header-explore .arrow-body { background: rgb(202, 138, 4); }
	.header-explore .arrow-point::before { border-left-color: rgb(202, 138, 4); }

	.header-learn .arrow-body { background: rgb(59, 130, 246); }
	.header-learn .arrow-point::before { border-left-color: rgb(59, 130, 246); }

	.header-adopt .arrow-body { background: rgb(22, 163, 74); }
	.header-adopt .arrow-point::before { border-left-color: rgb(22, 163, 74); }

	.header-advocate .arrow-body { background: rgb(var(--brand-primary)); }
	.header-advocate .arrow-point::before { border-left-color: rgb(var(--brand-primary)); }

	.stage-label {
		font-size: 0.85rem;
		font-weight: 700;
		color: white;
		text-transform: uppercase;
		letter-spacing: 0.04em;
	}

	.stage-sublabel {
		font-size: 0.65rem;
		color: rgba(255, 255, 255, 0.75);
		margin-top: 0.125rem;
	}

	/* ===== PIPELINE LANES ===== */
	.pipeline-lanes {
		display: flex;
		flex-direction: column;
		gap: 1.5rem;
	}

	.lane-wrapper {
		animation: fadeInUp 0.4s ease-out backwards;
		animation-delay: calc(var(--lane-index) * 0.1s);
	}

	@keyframes fadeInUp {
		from {
			opacity: 0;
			transform: translateY(10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	/* Tab container */
	.lane-tabs {
		display: flex;
		justify-content: space-between;
		align-items: flex-end;
	}

	/* Manila folder tab */
	.lane-tab {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.5rem 1rem 0.375rem;
		background: var(--surface-card);
		border: 1px solid var(--surface-border);
		border-bottom: none;
		border-radius: 10px 10px 0 0;
		margin-left: 1rem;
		position: relative;
		z-index: 1;
		margin-bottom: -1px;
	}

	/* Hover tab on right */
	.lane-hover-tab {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.5rem 1rem 0.375rem;
		background: rgb(var(--brand-primary));
		border: 1px solid rgb(var(--brand-primary));
		border-bottom: none;
		border-radius: 10px 10px 0 0;
		margin-right: 1rem;
		margin-bottom: -1px;
		opacity: 0;
		visibility: hidden;
		transform: translateY(4px);
		transition: all 0.15s ease;
	}

	.lane-hover-tab.visible {
		opacity: 1;
		visibility: visible;
		transform: translateY(0);
	}

	.hover-tab-name {
		font-size: 0.75rem;
		font-weight: 700;
		text-transform: uppercase;
		letter-spacing: 0.04em;
		color: white;
	}

	.hover-tab-arrow {
		font-size: 0.875rem;
		color: rgba(255, 255, 255, 0.8);
	}

	.lane-icon {
		font-size: 1rem;
	}

	.lane-title {
		font-size: 0.75rem;
		font-weight: 700;
		text-transform: uppercase;
		letter-spacing: 0.04em;
		color: rgb(17, 24, 39);
	}

	html.dark .lane-title {
		color: rgb(255, 255, 255);
	}

	.lane-desc {
		font-size: 0.7rem;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.lane {
		overflow: hidden;
	}

	.lane-grid {
		display: grid;
		grid-template-columns: repeat(6, 1fr);
	}

	.lane-cell {
		padding: 0.5rem;
		min-height: 48px;
		border-right: 1px solid var(--surface-border);
		transition: background 0.2s ease;
		display: flex;
		align-items: center;
	}

	.lane-cell:last-child {
		border-right: none;
	}

	.lane-cell:hover {
		background: var(--surface-card-muted);
	}

	/* Subtle stage tints */
	.cell-skip { background: rgba(239, 68, 68, 0.03); }
	.cell-watch { background: rgba(249, 115, 22, 0.03); }
	.cell-explore { background: rgba(234, 179, 8, 0.03); }
	.cell-learn { background: rgba(59, 130, 246, 0.03); }
	.cell-adopt { background: rgba(34, 197, 94, 0.04); }
	.cell-advocate { background: rgb(var(--brand-primary) / 0.04); }

	html.dark .cell-skip { background: rgba(239, 68, 68, 0.06); }
	html.dark .cell-watch { background: rgba(249, 115, 22, 0.06); }
	html.dark .cell-explore { background: rgba(234, 179, 8, 0.06); }
	html.dark .cell-learn { background: rgba(59, 130, 246, 0.06); }
	html.dark .cell-adopt { background: rgba(34, 197, 94, 0.08); }
	html.dark .cell-advocate { background: rgb(var(--brand-primary) / 0.08); }

	.cell-content {
		display: flex;
		flex-wrap: wrap;
		gap: 0.5rem;
		align-content: center;
		align-items: center;
	}

	.cell-empty {
		min-height: 20px;
	}

	/* ===== TECH ICONS ===== */
	.tech-icon {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		width: 36px;
		height: 36px;
		background: var(--surface-card);
		border: 1px solid var(--surface-border);
		border-radius: 10px;
		text-decoration: none;
		transition: all 0.2s ease;
	}

	.tech-icon:hover {
		transform: scale(1.15);
		border-color: rgb(var(--brand-primary));
		box-shadow: 0 0 0 3px rgb(var(--brand-primary) / 0.2);
	}


	.icon-img {
		width: 22px;
		height: 22px;
		object-fit: contain;
		border-radius: 4px;
	}

	.icon-initial {
		width: 22px;
		height: 22px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: var(--surface-card-muted);
		border-radius: 4px;
		font-size: 0.7rem;
		font-weight: 700;
		color: rgb(17, 24, 39);
	}

	html.dark .icon-initial {
		color: rgb(255, 255, 255);
	}

	.icon-trajectory {
		position: absolute;
		bottom: -2px;
		right: -2px;
		font-size: 0.6rem;
		font-weight: 700;
		width: 14px;
		height: 14px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: var(--surface-card);
		border-radius: 50%;
		border: 1px solid var(--surface-border);
		line-height: 1;
	}

	.trajectory-rising { color: rgb(34, 197, 94); }
	.trajectory-stable { color: rgb(156, 163, 175); }
	.trajectory-falling { color: rgb(239, 68, 68); }

	html.dark .trajectory-rising { color: rgb(134, 239, 172); }
	html.dark .trajectory-stable { color: rgb(156, 163, 175); }
	html.dark .trajectory-falling { color: rgb(252, 165, 165); }



	/* ===== RESPONSIVE ===== */
	@media (max-width: 1024px) {
		.pipeline-header {
			overflow-x: auto;
			padding-bottom: 1rem;
		}

		.header-stage {
			min-width: 100px;
		}

		.lane-desc {
			display: none;
		}
	}

	@media (max-width: 768px) {
		.matrix-hero {
			padding: 3rem 0 2rem;
		}

		.hero-pipeline-preview {
			gap: 0.375rem;
		}

		.preview-stage {
			padding: 0.5rem 0.75rem;
			min-width: 50px;
		}

		.preview-count {
			font-size: 1rem;
		}

		.preview-label {
			font-size: 0.55rem;
		}

		.pipeline-header {
			display: none;
		}

		.lane-tab {
			margin-left: 0.5rem;
		}

		.lane-desc {
			display: none;
		}

		.lane-grid {
			display: flex;
			flex-direction: column;
		}

		.lane-cell {
			border-right: none;
			border-bottom: 1px solid var(--surface-border);
			min-height: auto;
			padding: 0.75rem;
			flex-direction: column;
			align-items: flex-start;
			gap: 0.5rem;
		}

		.lane-cell:empty,
		.lane-cell:has(.cell-empty) {
			display: none;
		}

		.lane-cell::before {
			content: attr(data-stage);
			display: block;
			font-size: 0.6rem;
			font-weight: 600;
			text-transform: uppercase;
			letter-spacing: 0.05em;
			opacity: 0.7;
		}

		.cell-skip::before { content: 'Skip'; color: rgb(239, 68, 68); }
		.cell-watch::before { content: 'Watch'; color: rgb(249, 115, 22); }
		.cell-explore::before { content: 'Explore'; color: rgb(202, 138, 4); }
		.cell-learn::before { content: 'Learn'; color: rgb(59, 130, 246); }
		.cell-adopt::before { content: 'Adopt'; color: rgb(34, 197, 94); }
		.cell-advocate::before { content: 'Advocate'; color: rgb(var(--brand-primary)); }

		.cell-content {
			gap: 0.75rem;
		}

		.tech-icon {
			width: 40px;
			height: 40px;
		}

		.icon-img {
			width: 24px;
			height: 24px;
		}

		.lane-hover-tab {
			display: none;
		}

		.card-back {
			display: none;
		}
	}

	/* ===== PLAYING CARD ===== */
	.card-back {
		max-height: 0;
		overflow: hidden;
		opacity: 0;
		transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, margin 0.3s ease;
		margin-top: 0;
	}

	.card-back.visible {
		max-height: 600px;
		opacity: 1;
		margin-top: 1rem;
	}

	/* Outer card wrapper - cream/off-white like real playing cards */
	.playing-card {
		background: #fffef5;
		border-radius: 16px;
		padding: 8px;
		box-shadow:
			0 1px 2px rgba(0, 0, 0, 0.06),
			0 4px 12px rgba(0, 0, 0, 0.08),
			0 12px 32px rgba(0, 0, 0, 0.12);
	}

	html.dark .playing-card {
		background: #1c2333;
		box-shadow:
			0 1px 2px rgba(0, 0, 0, 0.2),
			0 4px 12px rgba(0, 0, 0, 0.3),
			0 12px 32px rgba(0, 0, 0, 0.4);
	}

	/* Inner frame with border - like the printed area of a card */
	.card-frame {
		background: white;
		border: 2px solid #e5e0d5;
		border-radius: 12px;
		padding: 1.25rem;
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	html.dark .card-frame {
		background: #0d1117;
		border-color: #30363d;
	}

	/* Card Top - Identity section */
	.card-top {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 1rem;
		padding-bottom: 1rem;
		border-bottom: 1px solid #e5e0d5;
	}

	html.dark .card-top {
		border-bottom-color: #30363d;
	}

	.card-identity {
		display: flex;
		align-items: center;
		gap: 0.875rem;
	}

	.card-back-icon {
		width: 52px;
		height: 52px;
		object-fit: contain;
		border-radius: 10px;
		background: #fafaf8;
		padding: 6px;
		border: 1px solid #e5e0d5;
	}

	html.dark .card-back-icon {
		background: #161b22;
		border-color: #30363d;
	}

	.card-titles {
		display: flex;
		flex-direction: column;
		gap: 2px;
	}

	.card-back-name {
		font-size: 1.25rem;
		font-weight: 700;
		color: #1a1a1a;
		margin: 0;
	}

	html.dark .card-back-name {
		color: #e6edf3;
	}

	.card-back-position {
		font-size: 0.7rem;
		font-weight: 700;
		text-transform: uppercase;
		letter-spacing: 0.05em;
	}

	.card-back-position.status-skip { color: #cf222e; }
	.card-back-position.status-watch { color: #bf5700; }
	.card-back-position.status-explore { color: #9a6700; }
	.card-back-position.status-learn { color: #0969da; }
	.card-back-position.status-adopt { color: #1a7f37; }
	.card-back-position.status-advocate { color: rgb(var(--brand-primary)); }

	/* Large emoji on the right */
	.card-emoji {
		font-size: 2.75rem;
		line-height: 1;
	}

	/* Card Center - The Why */
	.card-center {
		min-height: 32px;
	}

	.card-back-why {
		font-size: 0.925rem;
		line-height: 1.55;
		color: #57606a;
		margin: 0;
	}

	html.dark .card-back-why {
		color: #8b949e;
	}

	/* Stats Strip */
	.card-stats-strip {
		display: flex;
		gap: 0.5rem;
		flex-wrap: wrap;
		padding: 0.875rem;
		background: #fafaf8;
		border-radius: 10px;
		border: 1px solid #e5e0d5;
	}

	html.dark .card-stats-strip {
		background: #161b22;
		border-color: #30363d;
	}

	.card-stat {
		flex: 1;
		min-width: 65px;
		display: flex;
		flex-direction: column;
		align-items: center;
		padding: 0.5rem 0.625rem;
		background: white;
		border-radius: 8px;
		border: 1px solid #e5e0d5;
	}

	html.dark .card-stat {
		background: #0d1117;
		border-color: #30363d;
	}

	.card-stat .stat-value {
		font-size: 1rem;
		font-weight: 800;
		color: #1a1a1a;
	}

	html.dark .card-stat .stat-value {
		color: #e6edf3;
	}

	.card-stat .stat-label {
		font-size: 0.55rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.03em;
		color: #8b949e;
	}

	/* Spicy Take */
	.card-back-spicy {
		display: none;
		align-items: flex-start;
		gap: 0.5rem;
		padding: 0.75rem 1rem;
		background: #fff5f5;
		border-radius: 10px;
		border: 1px solid #fecdd3;
	}

	.card-back-spicy.has-take {
		display: flex;
	}

	html.dark .card-back-spicy {
		background: rgba(248, 113, 113, 0.1);
		border-color: rgba(248, 113, 113, 0.3);
	}

	.spicy-icon {
		font-size: 1rem;
		flex-shrink: 0;
	}

	.spicy-take {
		font-size: 0.875rem;
		font-style: italic;
		color: #be123c;
		line-height: 1.45;
	}

	html.dark .spicy-take {
		color: #fda4af;
	}

	/* Card CTA */
	.card-cta-link {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 0.5rem;
		padding: 0.875rem 1.25rem;
		background: linear-gradient(135deg, rgb(var(--brand-primary)) 0%, rgb(var(--brand-secondary)) 100%);
		color: white;
		border-radius: 10px;
		font-size: 0.75rem;
		font-weight: 700;
		text-transform: uppercase;
		letter-spacing: 0.05em;
		text-decoration: none;
		transition: all 0.2s ease;
	}

	.card-cta-link:hover {
		transform: translateY(-1px);
		box-shadow: 0 4px 12px rgb(var(--brand-primary) / 0.3);
	}

	.card-cta-link svg {
		transition: transform 0.2s ease;
	}

	.card-cta-link:hover svg {
		transform: translateX(3px);
	}

	/* ===== GRAVEYARD SECTION ===== */
	.graveyard-section {
		margin-top: 3rem;
		padding-top: 2rem;
		border-top: 1px solid var(--surface-border);
	}

	.graveyard-header {
		display: flex;
		flex-direction: column;
		gap: 0.25rem;
		margin-bottom: 1rem;
	}

	.graveyard-title-group {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.graveyard-icon {
		font-size: 1.5rem;
	}

	.graveyard-title {
		font-size: 1.25rem;
		font-weight: 700;
		color: rgb(107, 114, 128);
		margin: 0;
	}

	html.dark .graveyard-title {
		color: rgb(156, 163, 175);
	}

	.graveyard-subtitle {
		font-size: 0.85rem;
		margin: 0;
		padding-left: 2.25rem;
	}

	.graveyard-grid {
		display: flex;
		flex-wrap: wrap;
		gap: 0.75rem;
		padding: 1rem;
		background: rgba(107, 114, 128, 0.05);
	}

	html.dark .graveyard-grid {
		background: rgba(55, 65, 81, 0.3);
	}

	.graveyard-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.5rem 0.75rem;
		background: var(--surface-card);
		border: 1px solid var(--surface-border);
		border-radius: 10px;
		text-decoration: none;
		transition: all 0.2s ease;
		opacity: 0.7;
	}

	.graveyard-item:hover {
		opacity: 1;
		transform: translateY(-2px);
		border-color: rgb(107, 114, 128);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
	}

	html.dark .graveyard-item:hover {
		border-color: rgb(156, 163, 175);
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	}

	.graveyard-icon-wrapper {
		width: 28px;
		height: 28px;
		display: flex;
		align-items: center;
		justify-content: center;
		filter: grayscale(70%);
		transition: filter 0.2s ease;
	}

	.graveyard-item:hover .graveyard-icon-wrapper {
		filter: grayscale(30%);
	}

	.graveyard-img {
		width: 24px;
		height: 24px;
		object-fit: contain;
		border-radius: 4px;
	}

	.graveyard-initial {
		width: 24px;
		height: 24px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: var(--surface-card-muted);
		border-radius: 4px;
		font-size: 0.7rem;
		font-weight: 700;
		color: rgb(107, 114, 128);
	}

	.graveyard-info {
		display: flex;
		flex-direction: column;
		gap: 0.125rem;
	}

	.graveyard-name {
		font-size: 0.8rem;
		font-weight: 600;
		color: rgb(75, 85, 99);
		line-height: 1.2;
	}

	html.dark .graveyard-name {
		color: rgb(209, 213, 219);
	}

	.graveyard-status {
		font-size: 0.6rem;
		font-weight: 600;
		text-transform: uppercase;
		letter-spacing: 0.04em;
	}

	.graveyard-status.status-deprecated {
		color: rgb(234, 179, 8);
	}

	.graveyard-status.status-abandoned {
		color: rgb(239, 68, 68);
	}

	html.dark .graveyard-status.status-deprecated {
		color: rgb(253, 224, 71);
	}

	html.dark .graveyard-status.status-abandoned {
		color: rgb(252, 165, 165);
	}

	@media (max-width: 768px) {
		.graveyard-section {
			margin-top: 2rem;
			padding-top: 1.5rem;
		}

		.graveyard-grid {
			gap: 0.5rem;
			padding: 0.75rem;
		}

		.graveyard-item {
			padding: 0.375rem 0.5rem;
		}

		.graveyard-name {
			font-size: 0.75rem;
		}
	}
</style>

<script>
	const statusLabels: Record<string, string> = {
		"skip": "Skip",
		"watch": "Watch",
		"explore": "Explore",
		"learn": "Learn",
		"adopt": "Adopt",
		"advocate": "Advocate",
	};

	const confidenceLabels: Record<string, string> = {
		"gut": "Gut",
		"some-experience": "Some XP",
		"deep-experience": "Deep XP",
	};

	const groupingLabels: Record<string, string> = {
		"plumbing": "Plumbing",
		"platform": "Platform",
		"observability": "Observability",
		"security": "Security",
	};

	// Format date string like "2020-03" to "Mar 2020"
	function formatDate(dateStr: string): string {
		if (!dateStr) return "‚Äî";
		const [year, month] = dateStr.split("-");
		if (!year || !month) return dateStr;
		const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
		return `${months[parseInt(month, 10) - 1]} ${year}`;
	}

	// ===== FILTER LOGIC =====
	const matrixContent = document.querySelector('.matrix-content');
	const filterButtons = document.querySelectorAll('.preview-stage[data-filter]');
	let activeFilter: string | null = null;

	filterButtons.forEach(button => {
		button.addEventListener('click', () => {
			const filter = button.getAttribute('data-filter');

			if (activeFilter === filter) {
				// Toggle off - clear filter
				activeFilter = null;
				matrixContent?.removeAttribute('data-filter');
				filterButtons.forEach(btn => btn.setAttribute('aria-pressed', 'false'));
			} else {
				// Set new filter
				activeFilter = filter;
				matrixContent?.setAttribute('data-filter', filter || '');
				filterButtons.forEach(btn => {
					btn.setAttribute('aria-pressed', btn.getAttribute('data-filter') === filter ? 'true' : 'false');
				});
			}
		});
	});

	// ===== CARD BACK HOVER LOGIC =====
	let hideTimeout: ReturnType<typeof setTimeout> | null = null;
	let showTimeout: ReturnType<typeof setTimeout> | null = null;
	let currentIcon: Element | null = null;

	document.querySelectorAll('.lane-wrapper').forEach(lane => {
		const hoverTab = lane.querySelector('.lane-hover-tab');
		const hoverName = lane.querySelector('.hover-tab-name');
		const cardBack = lane.querySelector('.card-back');

		if (!cardBack) return;

		const cardIcon = cardBack.querySelector('.card-back-icon') as HTMLImageElement;
		const cardName = cardBack.querySelector('.card-back-name');
		const cardPosition = cardBack.querySelector('.card-back-position');
		const cardWhy = cardBack.querySelector('.card-back-why');
		const statVideos = cardBack.querySelector('.stat-videos');
		const statArticles = cardBack.querySelector('.stat-articles');
		const statFirstUsed = cardBack.querySelector('.stat-first-used');
		const statLastUsed = cardBack.querySelector('.stat-last-used');
		const statConfidence = cardBack.querySelector('.stat-confidence');
		const spicyContainer = cardBack.querySelector('.card-back-spicy');
		const spicyTake = cardBack.querySelector('.spicy-take');
		const cardEmoji = cardBack.querySelector('.card-emoji');
		const ctaLink = cardBack.querySelector('.card-cta-link') as HTMLAnchorElement;

		function populateCardBack(icon: Element) {
			if (hideTimeout) {
				clearTimeout(hideTimeout);
				hideTimeout = null;
			}

			currentIcon = icon;

			const id = icon.getAttribute('data-id') || "";
			const name = icon.getAttribute('data-name') || "";
			const status = icon.getAttribute('data-status') || "";
			const grouping = icon.getAttribute('data-grouping') || "";
			const why = icon.getAttribute('data-why') || "";
			const firstUsed = icon.getAttribute('data-first-used') || "";
			const lastUsed = icon.getAttribute('data-last-used') || "";
			const makesMeFeel = icon.getAttribute('data-makes-me-feel') || "";
			const spicy = icon.getAttribute('data-spicy-take') || "";
			const videoCount = icon.getAttribute('data-video-count') || "0";
			const articleCount = icon.getAttribute('data-article-count') || "0";
			const confidence = icon.getAttribute('data-confidence') || "";
			const iconUrl = icon.getAttribute('data-icon') || "";

			// Populate card
			if (cardIcon) {
				cardIcon.src = iconUrl || "/apple-touch-icon.png";
				cardIcon.alt = name;
			}
			if (cardName) cardName.textContent = name;
			if (cardPosition) {
				cardPosition.textContent = `${statusLabels[status] || status} ¬∑ ${groupingLabels[grouping] || grouping}`;
				cardPosition.className = `card-back-position status-${status}`;
			}

			// Populate emoji (large on the right side)
			if (cardEmoji) {
				cardEmoji.textContent = makesMeFeel || "üéØ";
			}

			if (cardWhy) cardWhy.textContent = why || "No detailed notes yet.";
			if (statVideos) statVideos.textContent = videoCount;
			if (statArticles) statArticles.textContent = articleCount;
			if (statFirstUsed) statFirstUsed.textContent = formatDate(firstUsed);
			if (statLastUsed) statLastUsed.textContent = formatDate(lastUsed);
			if (statConfidence) statConfidence.textContent = confidenceLabels[confidence] || "‚Äî";

			if (spicyContainer && spicyTake) {
				if (spicy) {
					spicyTake.textContent = spicy;
					spicyContainer.classList.add('has-take');
				} else {
					spicyContainer.classList.remove('has-take');
				}
			}

			// Update CTA link
			if (ctaLink) {
				ctaLink.href = `/technology/${id}`;
			}

			// Show
			cardBack?.classList.add('visible');
		}

		function scheduleShowCardBack(icon: Element) {
			// Cancel any pending show
			if (showTimeout) {
				clearTimeout(showTimeout);
				showTimeout = null;
			}

			// If card is already visible with same icon, do nothing
			if (currentIcon === icon && cardBack?.classList.contains('visible')) {
				return;
			}

			// If card is already visible but different icon, wait 100ms before switching
			if (cardBack?.classList.contains('visible') && currentIcon !== icon) {
				showTimeout = setTimeout(() => {
					populateCardBack(icon);
				}, 100);
			} else {
				// First hover - show immediately
				populateCardBack(icon);
			}
		}

		function hideCardBack() {
			// Cancel any pending show
			if (showTimeout) {
				clearTimeout(showTimeout);
				showTimeout = null;
			}

			hideTimeout = setTimeout(() => {
				cardBack?.classList.remove('visible');
				currentIcon = null;
			}, 150);
		}

		lane.querySelectorAll('.tech-icon').forEach(icon => {
			icon.addEventListener('mouseenter', () => {
				const name = icon.getAttribute('data-name');
				if (hoverName && hoverTab) {
					hoverName.textContent = name;
					hoverTab.classList.add('visible');
				}
				scheduleShowCardBack(icon);
			});

			icon.addEventListener('mouseleave', () => {
				if (hoverTab) {
					hoverTab.classList.remove('visible');
				}
				// Don't hide immediately - let the user move to card back
			});
		});

		// Track if mouse leaves the lane entirely
		lane.addEventListener('mouseleave', () => {
			hideCardBack();
		});

		// Keep card visible when hovering over it
		cardBack.addEventListener('mouseenter', () => {
			if (hideTimeout) {
				clearTimeout(hideTimeout);
				hideTimeout = null;
			}
			if (showTimeout) {
				clearTimeout(showTimeout);
				showTimeout = null;
			}
		});

		cardBack.addEventListener('mouseleave', () => {
			hideCardBack();
		});
	});
</script>

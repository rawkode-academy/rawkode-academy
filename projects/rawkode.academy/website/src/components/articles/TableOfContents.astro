---
import type { MarkdownHeading } from "astro";

type Props = {
	headings: MarkdownHeading[];
	class?: string;
};

const { headings, class: className = "" } = Astro.props;

type TocHeading = MarkdownHeading & { subheadings: MarkdownHeading[] };

const filteredHeadings = headings.filter(
	(heading) => heading.depth === 2 || heading.depth === 3,
);

const tocHeadings: TocHeading[] = filteredHeadings.reduce<TocHeading[]>(
	(acc, heading) => {
		if (heading.depth === 2) {
			const h2Heading: TocHeading = { ...heading, subheadings: [] };
			acc.push(h2Heading);
		} else if (heading.depth === 3 && acc.length > 0) {
			const lastH2 = acc[acc.length - 1];
			if (lastH2) {
				lastH2.subheadings.push(heading);
			}
		}
		return acc;
	},
	[],
);
---

<!-- Mobile toggle -->
<button
	id="toc-mobile-toggle"
	class="md:hidden fixed top-24 right-0 z-50 p-2.5 rounded-l-xl shadow-lg"
	style="background: var(--surface-card); border: 1px solid var(--surface-border); border-right: none;"
	aria-label="Toggle table of contents"
>
	<svg
		id="toc-icon-open"
		xmlns="http://www.w3.org/2000/svg"
		class="h-5 w-5 text-primary"
		fill="none"
		viewBox="0 0 24 24"
		stroke="currentColor"
		stroke-width="2"
	>
		<path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h7" />
	</svg>
	<svg
		id="toc-icon-close"
		xmlns="http://www.w3.org/2000/svg"
		class="h-5 w-5 text-primary hidden"
		fill="none"
		viewBox="0 0 24 24"
		stroke="currentColor"
		stroke-width="2"
	>
		<path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
	</svg>
</button>

<!-- TOC Container -->
<aside
	id="toc-container"
	class={`toc-container ${className}`}
	aria-label="Table of contents"
>
	<!-- Glass background -->
	<div class="toc-glass"></div>
	
	<!-- Content wrapper -->
	<div class="toc-content-wrapper">
		<!-- Minimized: dot navigation with progress track -->
		<div class="toc-dots">
			<!-- Progress track background -->
			<div class="toc-track"></div>
			<!-- Animated progress fill -->
			<div class="toc-progress" id="toc-progress"></div>
			<!-- Dots -->
			{tocHeadings.map((heading, i) => (
				<a
					href={`#${heading.slug}`}
					class="toc-dot"
					data-index={i}
					data-slug={heading.slug}
					title={heading.text}
				>
					<span class="toc-dot-inner"></span>
					<span class="toc-dot-ring"></span>
				</a>
			))}
		</div>

		<!-- Expanded: full TOC -->
		<div class="toc-full">
			<div class="toc-header">
				<span class="toc-label">Contents</span>
			</div>
			<nav class="toc-nav">
				<ul class="toc-list">
					{tocHeadings.map((heading) => (
						<li class="toc-item" data-slug={heading.slug}>
							<a href={`#${heading.slug}`} class="toc-link">
								<span class="toc-marker"></span>
								<span class="toc-text">{heading.text}</span>
							</a>
							{heading.subheadings.length > 0 && (
								<ul class="toc-sublist">
									{heading.subheadings.map((sub) => (
										<li class="toc-subitem" data-slug={sub.slug}>
											<a href={`#${sub.slug}`} class="toc-sublink">
												{sub.text}
											</a>
										</li>
									))}
								</ul>
							)}
						</li>
					))}
				</ul>
			</nav>
		</div>
	</div>
</aside>

<style>
	.toc-container {
		position: fixed;
		right: 0.5rem;
		top: 50%;
		transform: translateY(-50%);
		z-index: 40;
		width: 3rem;
		transition: width 0.25s ease;
	}

	.toc-container:hover,
	.toc-container.expanded {
		width: 18rem;
	}

	@media (min-width: 1280px) {
		.toc-container:hover,
		.toc-container.expanded {
			width: 22rem;
		}
	}

	.toc-glass {
		position: absolute;
		inset: 0;
		background: var(--surface-card);
		border: 1px solid var(--surface-border);
		border-radius: 1rem;
		box-shadow: var(--surface-shadow);
		backdrop-filter: blur(20px);
		-webkit-backdrop-filter: blur(20px);
	}

	.toc-content-wrapper {
		position: relative;
		z-index: 1;
		padding: 1rem 0.5rem;
		max-height: 70vh;
		overflow: hidden;
	}

	.toc-container:hover .toc-content-wrapper,
	.toc-container.expanded .toc-content-wrapper {
		overflow-y: auto;
		padding: 1rem;
	}

	/* Minimized dots with progress track */
	.toc-dots {
		position: relative;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 0.75rem;
		padding: 0.5rem 0;
		transition: opacity 0.2s ease;
	}

	.toc-container:hover .toc-dots,
	.toc-container.expanded .toc-dots {
		opacity: 0;
		visibility: hidden;
		position: absolute;
	}

	/* Vertical track line (background) - positioned via JS */
	.toc-track {
		position: absolute;
		left: 50%;
		width: 3px;
		transform: translateX(-50%);
		background: rgb(var(--brand-primary) / 0.12);
		border-radius: 2px;
		z-index: 0;
		/* Default position, will be updated by JS */
		top: calc(0.5rem + 7px);
		bottom: calc(0.5rem + 7px);
	}

	/* Animated progress fill - starts from first dot center */
	.toc-progress {
		position: absolute;
		left: 50%;
		width: 3px;
		height: 0;
		transform: translateX(-50%);
		background: linear-gradient(180deg, 
			rgb(var(--brand-primary)) 0%, 
			rgb(var(--brand-secondary)) 100%
		);
		border-radius: 2px;
		z-index: 1;
		transition: height 0.25s cubic-bezier(0.4, 0, 0.2, 1);
		/* Will be positioned via JS to match first dot center */
		top: calc(0.5rem + 7px);
		box-shadow: 0 0 6px 1px rgb(var(--brand-primary) / 0.4);
	}

	/* Glowing effect on the progress line tip */
	.toc-progress::after {
		content: '';
		position: absolute;
		bottom: -4px;
		left: 50%;
		transform: translateX(-50%);
		width: 10px;
		height: 10px;
		background: rgb(var(--brand-primary));
		border-radius: 50%;
		box-shadow: 0 0 12px 4px rgb(var(--brand-primary) / 0.7);
		opacity: 1;
		transition: opacity 0.25s ease;
	}

	.toc-dot {
		position: relative;
		display: flex;
		align-items: center;
		justify-content: center;
		width: 14px;
		height: 14px;
		border-radius: 50%;
		background: var(--surface-card);
		border: 2px solid rgb(var(--brand-primary) / 0.3);
		transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
		z-index: 2;
	}

	.toc-dot-inner {
		width: 4px;
		height: 4px;
		border-radius: 50%;
		background: rgb(var(--brand-primary) / 0.3);
		transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
	}

	.toc-dot:hover {
		border-color: rgb(var(--brand-primary) / 0.6);
		transform: scale(1.15);
	}

	.toc-dot:hover .toc-dot-inner {
		background: rgb(var(--brand-primary) / 0.6);
		transform: scale(1.2);
	}

	/* Passed state - sections already scrolled past */
	.toc-dot.passed {
		border-color: rgb(var(--brand-primary));
		background: rgb(var(--brand-primary));
		box-shadow: 0 0 6px 2px rgb(var(--brand-primary) / 0.3);
	}

	.toc-dot.passed .toc-dot-inner {
		background: white;
		width: 6px;
		height: 6px;
	}

	/* Active state - current section */
	.toc-dot.active {
		border-color: rgb(var(--brand-primary));
		border-width: 2px;
		background: var(--surface-card);
		transform: scale(1.25);
		box-shadow: 0 0 10px 3px rgb(var(--brand-primary) / 0.5);
	}

	.toc-dot.active .toc-dot-inner {
		background: rgb(var(--brand-primary));
		width: 6px;
		height: 6px;
		animation: dot-pulse 1.5s ease-in-out infinite;
	}

	.toc-dot.active .toc-dot-ring {
		position: absolute;
		inset: -6px;
		border: 2px solid rgb(var(--brand-primary) / 0.5);
		border-radius: 50%;
		animation: ring-pulse 1.5s ease-out infinite;
	}

	@keyframes dot-pulse {
		0%, 100% { transform: scale(1); }
		50% { transform: scale(1.15); }
	}

	@keyframes ring-pulse {
		0% { transform: scale(1); opacity: 0.8; }
		50% { transform: scale(1.3); opacity: 0.4; }
		100% { transform: scale(1.5); opacity: 0; }
	}

	/* Expanded full TOC */
	.toc-full {
		opacity: 0;
		visibility: hidden;
		transition: opacity 0.2s ease;
	}

	.toc-container:hover .toc-full,
	.toc-container.expanded .toc-full {
		opacity: 1;
		visibility: visible;
	}

	.toc-header {
		padding-bottom: 0.75rem;
		margin-bottom: 0.75rem;
		border-bottom: 1px solid var(--surface-border);
	}

	.toc-label {
		font-size: 0.625rem;
		font-weight: 700;
		text-transform: uppercase;
		letter-spacing: 0.15em;
		color: rgb(var(--brand-primary));
	}

	.toc-list {
		list-style: none;
		margin: 0;
		padding: 0;
	}

	.toc-item {
		margin-bottom: 0.125rem;
	}

	.toc-link {
		display: flex;
		align-items: flex-start;
		gap: 0.625rem;
		padding: 0.5rem 0.625rem;
		margin: 0 -0.625rem;
		border-radius: 0.5rem;
		font-size: 0.8125rem;
		font-weight: 500;
		color: rgb(107 114 128);
		text-decoration: none;
		line-height: 1.4;
		transition: all 0.15s ease;
	}

	:root.dark .toc-link {
		color: rgb(156 163 175);
	}

	.toc-link:hover {
		color: rgb(var(--brand-primary));
		background: rgb(var(--brand-primary) / 0.08);
	}

	:root.dark .toc-link:hover {
		background: rgb(var(--brand-primary) / 0.12);
	}

	.toc-link.active {
		color: rgb(var(--brand-primary));
		background: rgb(var(--brand-primary) / 0.1);
	}

	:root.dark .toc-link.active {
		background: rgb(var(--brand-primary) / 0.15);
	}

	.toc-marker {
		flex-shrink: 0;
		width: 6px;
		height: 6px;
		margin-top: 0.4em;
		border-radius: 50%;
		background: currentColor;
		opacity: 0.4;
		transition: all 0.15s ease;
	}

	.toc-link.active .toc-marker {
		background: rgb(var(--brand-primary));
		opacity: 1;
		box-shadow: 0 0 0 3px rgb(var(--brand-primary) / 0.2);
	}

	.toc-text {
		flex: 1;
		min-width: 0;
	}

	.toc-sublist {
		list-style: none;
		margin: 0;
		padding: 0 0 0 1.25rem;
	}

	.toc-subitem {
		margin: 0;
	}

	.toc-sublink {
		display: block;
		padding: 0.3rem 0.625rem;
		margin: 0 -0.625rem;
		font-size: 0.75rem;
		color: rgb(107 114 128);
		text-decoration: none;
		line-height: 1.4;
		border-radius: 0.375rem;
		transition: all 0.15s ease;
	}

	:root.dark .toc-sublink {
		color: rgb(156 163 175);
	}

	.toc-sublink:hover {
		color: rgb(var(--brand-secondary));
		background: rgb(var(--brand-secondary) / 0.08);
	}

	.toc-sublink.active {
		color: rgb(var(--brand-secondary));
	}

	/* Mobile styles */
	@media (max-width: 767px) {
		.toc-container {
			position: fixed;
			right: 0;
			left: 0;
			top: auto;
			bottom: 0;
			width: 100%;
			transform: translateY(100%);
			transition: transform 0.3s ease;
		}

		.toc-container.mobile-visible {
			transform: translateY(0);
		}

		.toc-glass {
			border-radius: 1.5rem 1.5rem 0 0;
			border-bottom: none;
		}

		.toc-glass::before {
			display: none;
		}

		.toc-dots,
		.toc-track,
		.toc-progress {
			display: none;
		}

		.toc-full {
			opacity: 1;
			visibility: visible;
		}

		.toc-content-wrapper {
			padding: 1.5rem;
			max-height: 50vh;
			overflow-y: auto;
		}

		.toc-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.toc-header::after {
			content: '';
			width: 3rem;
			height: 4px;
			background: rgb(var(--brand-primary) / 0.3);
			border-radius: 2px;
			position: absolute;
			top: 0.75rem;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script>
	// Initialize TOC functionality
	function initTOC() {
		const container = document.getElementById('toc-container');
		const toggle = document.getElementById('toc-mobile-toggle');

		if (!container || !toggle) return;

		// Remove old listeners by cloning
		const newToggle = toggle.cloneNode(true) as HTMLElement;
		toggle.parentNode?.replaceChild(newToggle, toggle);

		// Mobile toggle click
		newToggle.addEventListener('click', (e) => {
			e.preventDefault();
			e.stopPropagation();
			const isVisible = container.classList.toggle('mobile-visible');
			const openIcon = newToggle.querySelector('#toc-icon-open');
			const closeIcon = newToggle.querySelector('#toc-icon-close');
			openIcon?.classList.toggle('hidden', isVisible);
			closeIcon?.classList.toggle('hidden', !isVisible);
		});

		// Close on outside click
		function handleOutsideClick(e: MouseEvent) {
			if (
				container?.classList.contains('mobile-visible') &&
				!container?.contains(e.target as Node) &&
				!newToggle.contains(e.target as Node)
			) {
				container?.classList.remove('mobile-visible');
				const openIcon = newToggle.querySelector('#toc-icon-open');
				const closeIcon = newToggle.querySelector('#toc-icon-close');
				openIcon?.classList.remove('hidden');
				closeIcon?.classList.add('hidden');
			}
		}
		document.removeEventListener('click', handleOutsideClick);
		document.addEventListener('click', handleOutsideClick);

		// Close when clicking a link inside TOC
		container.querySelectorAll('a').forEach(link => {
			link.addEventListener('click', () => {
				if (window.innerWidth < 768) {
					container.classList.remove('mobile-visible');
					const openIcon = newToggle.querySelector('#toc-icon-open');
					const closeIcon = newToggle.querySelector('#toc-icon-close');
					openIcon?.classList.remove('hidden');
					closeIcon?.classList.add('hidden');
				}
			});
		});

		// Touch: tap to expand on tablet
		if ('ontouchstart' in window && window.innerWidth >= 768) {
			container.addEventListener('click', (e) => {
				if ((e.target as HTMLElement).closest('a')) return;
				container.classList.toggle('expanded');
			});
		}
	}

	// Update active state and progress based on scroll
	function updateActive() {
		// Only look for headings within the article prose content
		const headings = Array.from(document.querySelectorAll('.prose h2[id], .prose h3[id]')) as HTMLElement[];
		const h2Headings = Array.from(document.querySelectorAll('.prose h2[id]')) as HTMLElement[];
		
		const dots = document.querySelectorAll('.toc-dot');
		const links = document.querySelectorAll('.toc-link, .toc-sublink');
		const progress = document.getElementById('toc-progress');
		const dotsContainer = document.querySelector('.toc-dots');

		if (!headings.length || !h2Headings.length || !dots.length) return;

		const scrollY = window.scrollY + 160;
		let activeSlug = '';
		let activeH2Slug = '';
		let activeH2Index = 0; // Default to first heading

		// Find active headings - use the one we've scrolled past
		for (let i = 0; i < headings.length; i++) {
			const h = headings[i];
			if (h && h.offsetTop <= scrollY) {
				activeSlug = h.id;
				if (h.tagName === 'H2') activeH2Slug = h.id;
			}
		}

		// If no heading scrolled past yet, use the first one
		const firstH2 = h2Headings[0];
		if (!activeH2Slug && firstH2) {
			activeH2Slug = firstH2.id;
			activeSlug = firstH2.id;
		}

		// Find index by matching dot slug to activeH2Slug
		const dotSlugs = Array.from(dots).map(d => d.getAttribute('data-slug'));
		const matchedIndex = dotSlugs.indexOf(activeH2Slug);
		if (matchedIndex !== -1) {
			activeH2Index = matchedIndex;
		} else {
			// Fallback: find by position in h2 list
			h2Headings.forEach((h, i) => {
				if (h.id === activeH2Slug && i < dots.length) activeH2Index = i;
			});
		}

		// Update links
		links.forEach((link) => {
			const href = link.getAttribute('href')?.slice(1);
			const isActive = href === activeSlug;
			const isParentActive = link.classList.contains('toc-link') && 
				link.closest('.toc-item')?.getAttribute('data-slug') === activeH2Slug;
			link.classList.toggle('active', isActive || (isParentActive && activeSlug !== activeH2Slug));
		});

		// Update dots with passed/active states
		dots.forEach((dot, index) => {
			const isActive = dot.getAttribute('data-slug') === activeH2Slug;
			const isPassed = index < activeH2Index;
			
			dot.classList.toggle('active', isActive);
			dot.classList.toggle('passed', isPassed);
		});

		// Update progress line and track positioning
		if (progress && dotsContainer && dots.length > 0) {
			const firstDot = dots[0] as HTMLElement;
			const lastDot = dots[dots.length - 1] as HTMLElement;
			const track = document.querySelector('.toc-track') as HTMLElement;
			
			if (firstDot && lastDot) {
				// Calculate the track bounds (from first dot center to last dot center)
				const firstDotCenter = firstDot.offsetTop + firstDot.offsetHeight / 2;
				const lastDotCenter = lastDot.offsetTop + lastDot.offsetHeight / 2;
				const trackHeight = lastDotCenter - firstDotCenter;
				
				// Update track position to span from first to last dot center
				if (track) {
					track.style.top = `${firstDotCenter}px`;
					track.style.height = `${trackHeight}px`;
					track.style.bottom = 'auto';
				}
				
				// Update progress start position
				progress.style.top = `${firstDotCenter}px`;
				
				// Calculate progress based on active section
				let progressHeight = 0;
				
				if (trackHeight > 0) {
					const activeDot = dots[activeH2Index] as HTMLElement;
					if (activeDot) {
						const activeDotCenter = activeDot.offsetTop + activeDot.offsetHeight / 2;
						progressHeight = activeDotCenter - firstDotCenter;
						
						// Add progress within the current section
						if (activeH2Index < h2Headings.length - 1) {
							const currentH2 = h2Headings[activeH2Index];
							const nextH2 = h2Headings[activeH2Index + 1];
							if (!currentH2 || !nextH2) return;
							const sectionStart = currentH2.offsetTop;
							const sectionEnd = nextH2.offsetTop;
							const sectionProgress = Math.min(1, Math.max(0, 
								(scrollY - sectionStart) / (sectionEnd - sectionStart)
							));
							
							// Calculate the segment height to the next dot
							if (activeH2Index < dots.length - 1) {
								const nextDot = dots[activeH2Index + 1] as HTMLElement;
								const segmentHeight = nextDot.offsetTop - activeDot.offsetTop;
								progressHeight += segmentHeight * sectionProgress * 0.95;
							}
						} else {
							// Last section - fill to end as we scroll through
							const lastCurrentH2 = h2Headings[activeH2Index];
							const articleEnd = document.querySelector('.prose')?.getBoundingClientRect();
							if (articleEnd && lastCurrentH2) {
								const endY = articleEnd.bottom + window.scrollY;
								const sectionStart = lastCurrentH2.offsetTop;
								const sectionProgress = Math.min(1, Math.max(0,
									(scrollY - sectionStart) / (endY - sectionStart)
								));
								const remainingHeight = trackHeight - progressHeight;
								progressHeight += remainingHeight * sectionProgress;
							}
						}
					}
				}
				
				// Apply the progress height
				progress.style.height = `${Math.max(0, progressHeight)}px`;
			}
		}
	}

	// Initialize on page load
	initTOC();
	updateActive();
	// Run again after a short delay to handle hash navigation
	setTimeout(updateActive, 100);
	setTimeout(updateActive, 300);

	// Re-init on Astro page navigation
	document.addEventListener('astro:page-load', () => {
		initTOC();
		updateActive();
		setTimeout(updateActive, 100);
		setTimeout(updateActive, 300);
	});

	// Handle hash changes (when clicking TOC links)
	window.addEventListener('hashchange', () => {
		setTimeout(updateActive, 50);
	});

	window.addEventListener('scroll', updateActive, { passive: true });
</script>
